
template_code = """

#include <stdlib.h>

int func(int *array) {
    /* 
    Размер переданного массива измениться, это связано с тем, 
    что происходит передача указателя, а не самого объекта массива 
    */
    int size_array = {[1]};
    if (sizeof(array) != size_array) {
        return 1;
    }
    return 0;
}

int main() {
    /* Создаем массив целых чисел и объявляем 5 чисел */
    int array[5];
    array[0] = $$int_ans_0$$;
    array[1] = $$int_ans_1$$;
    array[2] = $$int_ans_2$$;
    array[3] = $$int_ans_3$$;
    array[4] = $$int_ans_4$$;

    /*
     Массив - это последовательность данных в памяти, 
     где каждый элемент имеет размер, соответствующий типу (в данном случае int)
    */

    /*
     * Имя переменной массива - это просто метка для адреса первого элемента
     * в массиве.
    */

    /* 
        Разыменование адреса данного элемента
        возвращает нам значение этого элемента
    */
    if (*array != {[2]}) {
        return 1;
    }

    /* 
        Разыменование ссылок со смещением аналогично использованию 
        обозначения в квадратных скобках для доступа к элементу
    */
    if (*(array + $$offset_array$$) != array[{[3]}]) {
        return 2;
    }


    /*
    * Важным унарным оператором в языке C является sizeof.
    *
    * Оператор sizeof вычисляет размер переменной или типа данных.
    * Результат измеряется в количестве байт (единиц хранения размером с char),
    * необходимых для хранения значения этого типа.
    *
    * Таким образом, конструкция sizeof(char) всегда возвращает 1,
    * потому что размер char принят за единицу измерения.
    *
    * Точное количество бит в типе char определяется макросом CHAR_BIT,
    * который объявлен в заголовочном файле limits.h.
    * На большинстве современных систем CHAR_BIT равен 8 (то есть 1 байт = 8 бит).
    *
    * Результат sizeof имеет беззнаковый целочисленный тип, который обычно обозначается как size_t.
    *
    * Оператор sizeof записывается перед своим операндом и может применяться:
    * - к переменной (например: sizeof x);
    * - к типу данных (например: sizeof(int), sizeof(double), sizeof(struct MyStruct)).
    * 
    * Если sizeof применяется к типу, этот тип обязательно должен быть заключён в круглые скобки.
    * 
    * Оператор sizeof можно использовать с любыми типами:
    * - примитивными (int, float, double и т. д.),
    * - указателями,
    * - составными типами (структуры, объединения).
    */

    /*
    * Использование sizeof с массивом может сбивать с толку.
    * Возникает вопрос: это размер указателя или всей памяти массива?
    *
    * Если массив — это переменная, sizeof вернёт весь размер массива.
    * Если это указатель (например, аргумент функции), вернётся размер указателя.
    */

    if (sizeof(array) != {[4]}) {
        return 3;
    }

    /* функция объявлена над функцией main */
    if (func(array) == 1) {
        return 4;
    }


    /*
    * Не обязательно писать много строк, чтобы создать массив с уже известными значениями.
    * Можно элегантно задать его с помощью синтаксиса { ... } при инициализации.
    */

    int another_array[$$size_random_array$$] = $$random_array$$;

    if (another_array[$$random_element_array$$] != {[5]}) {
        return 5;
    }

    /*
    * Во время выполнения программы не всегда известно,
    * сколько элементов будет в массиве.
    *
    * В таких случаях нельзя использовать обычный синтаксис инициализации.
    * Вместо этого массив нужно рассматривать как указатель,
    * а затем работать с ним как с массивом.
    */

    const size_t INIT_ARR_SIZE = $$size_random_array$$;

    
    // Функция calloc - инициализирует область памяти нужного размера нулями

    int *yet_another_array = calloc(INIT_ARR_SIZE, sizeof(int));

    unsigned i;
    for (i = 0; i < INIT_ARR_SIZE; i++) {
        /*
        * По массиву можно проходить в цикле,
        * главное — правильно обрабатывать индексы.
        */
        yet_another_array[i] = i + 1;
    }

    /*
    * Когда нужно, можно увеличить размер массива с помощью realloc.
    * Адрес массива может измениться, поэтому всегда нужно переназначать указатель.
    */
    if (!(yet_another_array
            = realloc(yet_another_array, INIT_ARR_SIZE * sizeof(int)))) {
        exit(1);
    }

    yet_another_array[INIT_ARR_SIZE] = $$short_ans$$;
    unsigned where = 0;
    for (i = 0; i < INIT_ARR_SIZE + 1; i++) {
        if (yet_another_array[i] == INIT_ARR_SIZE + 1) {
            where = i;
        }

        /*
        * Хотя мы начали с массива из $$size_random_array$$ элементов,
        * мы должны иметь возможность добавить шестой элемент.
        */
        // Тут вопросик: надо протестить, потому что ответ тут i + 1 
        if (yet_another_array[i] != {[6]}) {
            return 6;
        }
    }

    /*
    * Мы должны увидеть определённое значение, 
    * учитывая, как мы установили значения этих элементов.
    */
    
    if (where != {[7]}) {
        return 7;
    }

    /*
    * Часто нам нужно представлять строки в программе,
    * и обычно для этого используется класс или тип String.
    * К сожалению, в языке C нет встроенного понятия строки, 
    * как это реализовано в некоторых других языках (например, Java).
    */

    const char a_string[13] = "hello world!"; /* Это "строка" в Cи. */

    /*
    * В языке C строка — это просто массив символов.
    */
    if (a_string[$$random_element_string$$] != {[8]}) {
        return 8;
    }

    /*
    * В языке C память — это просто куча байт.
    * Поэтому нам нужно как-то определить конец строки.
    * Для этого используется так называемый 'нулевой байт' или 'нулевой терминатор',
    * который на самом деле является байтом со значением 0.
    * Этот байт всегда находится в конце строки, и его отсутствие
    * может привести к очень опасным и непредсказуемым ошибкам.
    */

    if (a_string[12] != {[9]}) {
        return 9;
    }
    return 0;
}

"""






template_coderunner = '''
import subprocess, sys, re


def find_substrings(text, substrings): 
    pattern = re.compile('|'.join(map(re.escape, substrings)))
    return pattern.findall(text)


def check_student_answers_for_substrings(student_answers,substrings):
    for answer in student_answers:
        found_substring = find_substrings(answer, substrings)
        if found_substring:
            print(f"Your answer has {set(found_substring)} in this answer", answer)
            sys.exit()


def replacer(match):
    key = match.group(1)
    return template.get(key, match.group(0))


student_answer = {{ STUDENT_ANSWER }}

banned_words = ['exit', ';', 'return']
check_student_answers_for_substrings(student_answer, banned_words)

template = {str(ind + 1): s for ind, s in enumerate(student_answer)}

code = """
$$code$$
"""

pattern = re.compile(r'\{\[(\d+)\]\}')
student_code = pattern.sub(replacer, code)

with open("prog.c", "w") as src:
    print(student_code, file=src)

# Compile
{% if QUESTION.parameters.cflags is defined %}
cflags = """{{ QUESTION.parameters.cflags | e('py') }}"""
{% else %}
cflags = "-std=c99 -Wall -Werror"
{% endif %}

return_code = subprocess.call("gcc {0} -o prog prog.c".format(cflags).split())

if return_code != 0:
    sys.exit()

try:
    output = subprocess.check_output(["./prog"], universal_newlines=True)
    print('Ok')
except subprocess.CalledProcessError as e:
    if e.returncode > 0:
        print(f'Программа завершилась с кодом {e.returncode}, а ожидался код 0.')
    else:
        if e.output:
            print(e.output, file=sys.stderr)
'''

template_condition = "Заполните пропущенные значения переменных таким образом, чтобы программа завершалась с кодом 0."